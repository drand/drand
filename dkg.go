package main

import (
	"errors"
	"fmt"
	"sync"

	"github.com/nikkolasg/slog"

	"gopkg.in/dedis/kyber.v1/share/pedersen/dkg"
	"gopkg.in/dedis/kyber.v1/util/random"
)

// DKG is the structure responsible for running the DKG protocol.
type DKG struct {
	priv          *Private
	group         *Group
	store         Store
	addr          string
	n             int
	t             int
	idx           int
	router        *Router
	dkg           *dkg.DistKeyGenerator
	sentDeals     bool
	dealProcessed int
	respProcessed int
	shareCh       chan *Share
	done          bool
	sync.Mutex
}

func NewDKG(priv *Private, group *Group, r *Router, s Store) (*DKG, error) {
	d := &DKG{
		priv:   priv,
		group:  group,
		router: r,
		// default threshold
		t:       group.Threshold,
		addr:    priv.Public.Address,
		shareCh: make(chan *Share, group.Len()),
		store:   s,
	}
	d.idx, _ = group.Index(priv.Public)
	var err error
	// public key is in G2
	d.dkg, err = dkg.NewDistKeyGenerator(g2.(dkg.Suite), d.priv.Key, group.Points(), random.Stream, d.t)
	return d, err
}

// Start initiates the DKG protocol, it actively connects to every other nodes
// as an initiator. It returns the share generated if the protocol proceeded
// correctly.
func (d *DKG) Start() (*Share, error) {
	slog.Debugf("%s: is ROOT dkg", d.addr)
	d.sentDeals = true
	if err := d.sendDeals(true); err != nil {
		return nil, err
	}
	slog.Debugf("%s: ROOT wait dks", d.addr)
	share := <-d.shareCh
	return share, nil
}

// Run listens for any incoming DKG packet from an initiator. Once such a packet
// is received, it will start the DKG protocol by sending its shares. It returns
// the share generated by the protocol if it succeeded.
func (d *DKG) Run() (*Share, error) {
	share := <-d.shareCh
	slog.Debugf("%s: DKG.Run() Finished !", d.addr)
	return share, nil
}

func (d *DKG) process(pub *Public, dkg *DKGPacket) {
	switch {
	case dkg.Deal != nil:
		d.processDeal(pub, dkg.Deal)
	case dkg.Response != nil:
		d.processResponse(pub, dkg.Response)
	case dkg.Justification != nil:
		panic("not yet implemented")
	}
}

func (d *DKG) processDeal(pub *Public, deal *dkg.Deal) {
	d.dealProcessed++
	slog.Debugf("%s: processDeal(%d) from %s", d.addr, d.dealProcessed, pub.Address)
	resp, err := d.dkg.ProcessDeal(deal)
	if err != nil {
		slog.Infof("%s error processing deal: %s", d.addr, err)
		return
	}
	if !d.sentDeals {
		d.sendDeals(false)
		d.sentDeals = true
		slog.Debugf("%s: sent DEALS !", d.addr)
	}
	packet := &DrandPacket{
		Dkg: &DKGPacket{
			Response: resp,
		},
	}
	d.broadcast(packet)
	slog.Debugf("%s: broadcasted Response !")
}

func (d *DKG) processResponse(pub *Public, resp *dkg.Response) {
	d.respProcessed++
	j, err := d.dkg.ProcessResponse(resp)
	slog.Debugf("%s: processResponse(%d) from %s. len(QUAL) = %d", d.addr, d.respProcessed, pub.Address, len(d.dkg.QUAL()))
	if err != nil {
		slog.Infof("%s error process response: %s", d.addr, err)
	}
	if j != nil {
		slog.Debugf("%s: broadcasting Justification ", d.addr)
		packet := &DrandPacket{
			Dkg: &DKGPacket{
				Justification: j,
			},
		}
		d.broadcast(packet)
	}
	if d.dkg.Certified() {
		slog.Infof("%s: dkg certified !", d.addr)
		dks, err := d.dkg.DistKeyShare()
		if err != nil {
			return
		}
		share := Share(*dks)
		d.shareCh <- &share
		// save the file
		d.store.SaveShare(&share)
	}
}

// sendDeals tries to send the deals to each of the nodes. force indicates if
// the local nodeis the initiator or not, and therefore must actively initiates
// the connection or not.
// It returns an error if a number of node superior to the threshold have not
// received the deal. It is basically a no-go.
func (d *DKG) sendDeals(force bool) error {
	deals, err := d.dkg.Deals()
	if err != nil {
		return err
	}
	var send func(*Public, *DrandPacket) error
	if force {
		send = d.router.SendForce
	} else {
		send = d.router.Send
	}
	var good int = 1
	//z, _ := d.group.Index(d.priv.Public)
	//fmt.Printf("Index %d sendDeal() vs %d -- force ? %v\n ", d.idx, z, force)
	for i, deal := range deals {
		if i == d.idx {
			panic("stg's shaky")
		}
		pub := d.group.Public(i)
		packet := &DrandPacket{
			Dkg: &DKGPacket{
				Deal: deal,
			},
		}
		//fmt.Printf("%s sending deal to %s\n", d.addr, pub.Address)
		if err := send(pub, packet); err != nil {
			slog.Debugf(d.priv.Public.Address, " failed to send deal to ", pub.Address)
		} else {
			good++
		}
	}
	if good < d.t {
		return fmt.Errorf("dkg: could only send deals to %d / %d (threshold %d)", good, d.n, d.t)
	}
	slog.Infof("%s: sentDeals FINISHED to %d nodes !", d.addr, good-1)
	return nil
}

func (d *DKG) expectDeal(buff []byte) (*dkg.Deal, error) {
	drand, err := unmarshal(g2, buff)
	if err != nil {
		return nil, err
	}

	if drand.Dkg == nil {
		return nil, errors.New("dkg: received non DKG packet...")
	}

	if drand.Dkg.Deal == nil {
		return nil, errors.New("dkg: expected a Deal but got none...")
	}
	return drand.Dkg.Deal, nil
}

func (d *DKG) broadcast(packet *DrandPacket) {
	slog.Debugf("%s: broadcast INIT", d.addr)
	for _, ip := range d.group.List {
		if ip.Index == d.idx {
			continue
		}
		if err := d.router.Send(ip.Public, packet); err != nil {
			slog.Debugf("%s error sending packet to %s: %s", d.addr, ip.Address, err)
		}
	}
	slog.Debugf("%s: broadcast DONE", d.addr)
}
