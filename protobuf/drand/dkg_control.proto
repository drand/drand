syntax = "proto3";

package drand;

import "google/protobuf/timestamp.proto";
import "crypto/dkg/dkg.proto";
option go_package = "github.com/drand/drand/protobuf/drand";

// used between CLI and drand binary
service DKGControl {
  rpc StartNetwork(FirstProposalOptions) returns (EmptyResponse) {}
  rpc StartProposal(ProposalOptions) returns (EmptyResponse) {}
  rpc StartAbort(AbortOptions) returns (EmptyResponse) {}
  rpc StartExecute(ExecutionOptions) returns (EmptyResponse) {}

  rpc StartJoin(JoinOptions) returns (EmptyResponse) {}
  rpc StartAccept(AcceptOptions) returns (EmptyResponse) {}
  rpc StartReject(RejectOptions) returns (EmptyResponse) {}
  rpc DKGStatus(DKGStatusRequest) returns (DKGStatusResponse) {}
}

message FirstProposalOptions {
  string beaconID = 1;
  google.protobuf.Timestamp timeout = 2;
  uint32 threshold = 3;
  uint32 period_seconds = 4;
  string scheme = 5;
  uint32 catchup_period_seconds = 6;
  google.protobuf.Timestamp genesis_time = 7;
  repeated Participant joining = 8;
}

message ProposalOptions {
  string beaconID = 1;
  google.protobuf.Timestamp timeout = 2;
  uint32 threshold = 3;
  uint32 catchup_period_seconds = 4;
  google.protobuf.Timestamp transition_time = 5;
  repeated Participant joining = 6;
  repeated Participant leaving = 7;
  repeated Participant remaining = 8;
}

message AbortOptions {
  string beaconID = 1;
}

message ExecutionOptions {
  string beaconID = 1;
}

message JoinOptions {
  string beaconID = 1;
  bytes groupFile = 2;
}
message AcceptOptions {
  string beaconID = 1;
}

message RejectOptions {
  string beaconID = 1;
}

// used between nodes within the network
service DKG {
  rpc Propose(ProposalTerms) returns (EmptyResponse) {}
  rpc Abort(AbortDKG) returns (EmptyResponse) {}
  rpc Execute(StartExecution) returns (EmptyResponse) {}
  rpc Accept(AcceptProposal) returns (EmptyResponse) {}
  rpc Reject(RejectProposal) returns (EmptyResponse) {}
  // BroadcastPacket is used during DKG phases
  rpc BroadcastDKG(DKGPacket) returns (EmptyResponse) {}
}

message EmptyResponse {
}

message InitialProposal {
  string beaconID = 1;
  uint32 epoch = 2;
  Participant leader = 3;
  uint32 threshold = 4;

  // the time at which the proposal can be automatically cancelled if the leader
  // has not kicked off execution
  google.protobuf.Timestamp proposal_timeout = 5;

  // the minimum beacon period when in catchup
  uint32 catchup_period = 6;

  // the period time of the beacon in seconds.
  uint32 beacon_period = 7;

  // the cryptographic (and protocol) scheme used to generate randomness beacons
  // used only in a fresh dkg
  uint32 schemeID = 8;

  // the start time of the network
  google.protobuf.Timestamp genesis_time = 9;

  // a list of the participants taking part in the initial DKG
  repeated Participant joining = 10;
}

message Proposal {
  string beaconID = 1;
  uint32 epoch = 2;
  Participant leader = 3;
  uint32 threshold = 4;
  // the time at which the proposal can be automatically cancelled if the leader
  // has not kicked off execution
  google.protobuf.Timestamp timeout = 5;

  // the time at which a DKG should go live
  google.protobuf.Timestamp transition_time = 6;

  // a list of the participants joining for this epoch
  repeated Participant joining = 7;

  // a list of the participants from the current epoch that will remain for the next epoch
  repeated Participant remaining = 8;

  // a list of the participants from the current epoch that will leave for the next epoch
  repeated Participant leaving = 9;
}

message ProposalTerms {
  string beaconID = 1;
  uint32 epoch = 2;
  Participant leader = 3;
  uint32 threshold = 4;
  google.protobuf.Timestamp timeout = 5;
  uint32 catchup_period_seconds = 6;
  uint32 beacon_period_seconds = 7;
  string schemeID = 8;
  google.protobuf.Timestamp genesis_time = 9;
  bytes genesis_seed = 10; // joiners require this as they don't have the original group file to generate it
  google.protobuf.Timestamp transition_time = 11;

  repeated Participant joining = 12;
  repeated Participant remaining = 13;
  repeated Participant leaving = 14;
}

message Participant {
  string address = 1;
  bool tls = 2;
  bytes pubKey = 3;
  bytes signature = 4;
}

message AcceptProposal {
  Participant acceptor = 1;

  DKGMetadata metadata = 2;
}

message RejectProposal {
  // the person rejecting the proposal
  Participant rejector = 1;
  // the reason for rejection, if applicable
  string reason = 2;
  // signature over the proposal message that's being accepted

  // used to authenticate the user
  bytes secret = 3;

  // In resharing cases, previous_group_hash is the hash of the previous group.
  // It is to make sure the nodes build on top of the correct previous group.
  bytes previous_group_hash = 4;

  // a sha256 hash of the original proposal message
  bytes proposal_hash = 5;

  DKGMetadata metadata = 6;
}

message AbortDKG {
  string reason = 1;

  DKGMetadata metadata = 2;
}

message StartExecution {
  DKGMetadata metadata = 1;
}

message DKGMetadata {
  string beaconID = 1;
}

message DKGStatusRequest {
  string beaconID = 1;
}

message DKGStatusResponse {
  DKGEntry complete = 1;
  DKGEntry current = 2;
}

message DKGEntry {
  string beaconID = 1;
  uint32 state = 2;
  uint32 epoch = 3;
  uint32 threshold = 4;
  google.protobuf.Timestamp timeout = 5;
  google.protobuf.Timestamp genesis_time = 6;
  google.protobuf.Timestamp transition_time = 7;
  bytes genesis_seed = 8;
  Participant leader = 9;
  repeated Participant remaining = 10;
  repeated Participant joining = 11;
  repeated Participant leaving = 12;
  repeated Participant acceptors = 13;
  repeated Participant rejectors = 14;
  repeated string finalGroup = 15;
}

// DKGPacket is the packet that nodes send to others nodes as part of the
// broadcasting protocol.
message DKGPacket{
  dkg.Packet dkg = 1;
  DKGMetadata metadata = 2;
}
